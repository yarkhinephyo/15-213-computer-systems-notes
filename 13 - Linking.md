**Linking**: Collection and combining pieces of code and data into a single file for execution. Can be done at different times.

<ins>Compile time</ins>: Source code is translated into machine code.

<ins>load time</ins>: Program is loaded into memory and executed by the loader.

<ins>Run time</ins>: When instructions of the program are executed.

**Why linkers**: Enable separate compilation of a software. Code can be more modularized. Compilation time is reduced for individual modules. Executable size is reduced when shared libraries can be taken advantage of.

**Compiler driver**: Invokes the language preprocessor, compiler, assembler, linker on behalf of the user. An example is the GCC driver.

<ins>Language processor</ins>: GNU C Preprocessor includes the headers and expands the macros to convert `*.c` to `*.i`. 

<ins>Compiler</ins>: C compiler compiles preprocessed code to assembly code by converting `*.i` to `*.s` file. (Some compilers generate object code directly)

<ins>Assembler</ins>: Assembler converts the assembly code to machine code in the relocatable object file `*.o`.

<ins>Linker</ins>: Combines the object files to create a binary executable object file.

**Static Linkers**: Take a collection of relocatable object files and generate a fully-linked executable object file. The file consists of continguous code and data sections. The linkers must perform two functions.

<ins>Symbol resolution</ins>: Ensuring that each reference is associated with exactly one definition.

```c
void swap() {...} /* definition */
swap()            /* reference */
int *xp = &x;     /* definition & reference */
```

<ins>Symbol relocation</ins>: Addresses of symbol definitions from object files are associated with memory locations.

**Types of object files**

A relocatable object file is an `.o` file that is produced from one source `.c` file. An executable object file is an `a.out` file generated by the linker. A shared object file is a relocatable object `.so` file that can be loaded into memory and linked dynamically.

The object file format used by Linux and Unix is called _Executable and Linkable Format (ELF)_.

```
ELF header - Word size, byte ordering, file type (o, so, out)
Section header table - Where different sections are in memory

.text - Machine code
.rodata - Read only data such as jump tables
.data - Initialized global variables
.bss - Uninitialized global variables (No space taken by data)
.symtab - Symbol entries for procedures and global variables
.rel.text - Relocation info for .text section (Not needed in exe)
.rel.data - Relocation info for .data section (Not needed in exe)
.debug - Source code to line number in machine code
.strtab - String table for symbols in .symtab .debug

Section header table - Where different sections start
```

**Symbol**

<ins>Global symbols</ins>: Symbols defined by module "m" that can be referenced by other modules. Nonstatic C functions and global variables.

<ins>External symbols</ins>: Symbols that are referenced by module "m" but defined by other modules.

<ins>Local symbols</ins>: Symbols defined and referenced exclusively by module "m", such as static C functions and global variables. These are stored in `.bss` or `.data`. Local linker symbols are not the same as local program variables which are stored in the stack.

**Symbol table**: Assemblers use the symbols exported by compilers to build the table. This means `*.s` files do not have them yet. Each entry is shown below.

```c
typedef struct {
	int name;               /* .strtab offset */
	char type:4, binding:4; /* Function or data, local or global */
	char reserved;          /* Unused */
	short section;          /* Section header index */
	long value;             /* Section offset or abs address */
	long size;              /* Object size in bytes */
}
```

<ins>Pseudosections</ins>: Sections not indexed in the section header table. ABS means that the symbol should not be relocated. UNDEF means symbols are defined not in the module. COMMON means uninitialized data objects that are not allocated.

Uninitialized data objects may be defined in other modules so compiler defers the decision to the linker by assigning COMMON section in relocatable object files. COMMON section is not present in executable object files.

Aside from uninitialized variables... zero-initialized variables are assigned it to `.bss` instead of `.data` becuase at runtime, variables in this section are assigned zero. This saves space.

**Symbol resolution**

Straightforward for references to local symbols which are defined in the same module. Compiler ensures that static variables have unique names and defined only once.

It is more complex for global symbols. The compiler can accept undefined variables anyway and the failure will occur at the linker.

Compiler exports each global symbol either as <ins>strong</ins> (Procedures and initialized globals) or <ins>weak</ins> (Uninitialized globals). The assembler encodes the information implicitly in the symbol tables. The linker uses the following rules -

1. Multiple strong symbols not allowed.
2. Strong symbol is chosen over weak symbols.
3. If multiple weak symbols, an arbitrary one is picked.

For example, calling the function f() results in `x -> 0x0` and `y -> 0x80000000`.

```c
/* foo.c */
#include <stdio.h>

void f(void);
int y = 15213;   /* Address: 0x601020 */
int x = 15213;   /* Address: 0x601024 */
int main() {
	f();
	return 0;
}
```

```c
/* bar.c */
double x;        /* Assigned to 8-byte memory */
void f() {
	x = = -0.0;
}
```

**Static libraries**

Related functions are compiled into separate object modules and packaged into a single static library. At link time, the linker will only resolve object modules referenced by the program. On Linux, static libraries are stored in a format called _archive_ as `*.a` files.

To create a static library of multiple modules, we can use the AR tool -

```bash
gcc -c addvec.c multvec.c
ar rcs libvector.a addvec.o multvec.o
```

We can also create a `vector.h` header file to define the function prototypes.

```c
/* main2.c */
#include <stdio.h>
#include "vector.h"

int x[2] = {1, 2};
int y[2] = {3, 4};
int x[2];

int main() {
	addvec(x, y, z, 2);
	printf("z = [%d %d]\n", z[0], z[1]);
	return 0;
}
```

![](images/Pasted%20image%2020211230222607.png)

**Symbol resolution of static libraries**

Linker scans the relocatable object files and archives from left to right as given in the command line.

```
E = { relocatable object files to be merged }
U = { unresolved symbols }
D = { defined symbols }

for each file f (left to right):
	if f is relocatable object file:
		Add f to E.
		Update U and D with definitions and references.
	if f is an archive:
		Try to match symbols in U and add matched members to E.
		Update U and D with definitions and references.

if U is non-empty:
	Throw error
```

Rule of thumb is that static libraries should be ordered at the end of the command line. The libraries requiring dependencies should not be placed at the end.

**Relocation**

After symbol resolution, the linker knows the exact sizes of the code and data sections. In relocation, it merges the input modules and assign runtime addresses to each symbol. There are two steps.

<ins>Relocating sections</ins>: Linker aggregates sections of the same type and assign runtime addresses to sections and symbol definitions.

<ins>Relocating symbol references</ins>: Linker modifies every symbol reference so that each points to the correct runtime address. Linker relies on  _relocation entries_ for while have been generated by the assembler.

![](images/Pasted%20image%2020211229000322.png)

**Relocation entry**

Assembler generates a _relocation entry_ whenever external variables are referenced by the module. Entries for code are in `.rel.text` and entries for data are in `.rel.data`.

```c
typedef struct {
	long offset;  /* Section offset of the reference */
	long type:32, /* Relocation type */
	   symbol:32; /* Symbol table index */
	long addend;  /* Constant part of relocation expression */
} Elf64_Rela;
```

There are two relocation types. _R_X86_64_PC32_ is for PC-relative referencing. _R_X86_64_32_ is for absolute referencing.

**Relocation algorithm**

```
foreach section s {
	foreach relocation entry r {
		// Ptr to the placeholder bytes
		// The address in the current process (not runtime)
		refptr = s + r.offset;
		
		if (r.type == R_X86_64_PC32) {
			// The address during runtime
			refaddr = ADDR(s) + r.offset;
			*refptr = ADDR(r.symbol) + r.addend - refaddr;
		}
		
		if (r.type == R_X86_64_32)
			*refptr = ADDR(r.symbol) + r.addend;
	}
}
```

**Example of relocation**

At offset 0xa, `array` will have to be referenced with PC-relative address. At offset 0xf, `sum` will have to be referenced with absolute address.

```
int array[2] = {1, 2};
int main() {
	int val = sum(array, 2);
	return val;
}

0000000000000000 <main>:
 0: 48 83 ec 08     sub   $0x8, %rsp
 4: be 02 00 00 00  mov   $0x2, %esi
 9: bf 00 00 00 00  mov   $0x0, %edi      # %edi = &array
      (R_X86_64_32 array)
 e: e8 00 00 00 00  callq 13 <main+0x13>  # sum()
      (R_X86_64_PC32 sum-0x4)
13: 48 83 c4 09     add   $0x8, %rsp
17: c3              retq
```

At line 0xe, there is 1-byte opcode 0xe8 and a 4-byte placeholder for the PC-relative reference to `sum()` function. The placeholder will be replaced with PC-relative reference after the relocation algorithm is run. (Note: Jumps and Calls always use PC-relative addresses)

```c
r.offset = 0xf
r.symbol = sum
r.type   = R_X86_64_PC32
r.addend = -4
```

At line 0x9, there is 1-byte opcode and a 4-byte placeholder for the absolute reference to `array`. After relocation, the address will point to somewhere in the `.data` section.

At load time, the loader can copy the bytes directly into memory and execute without any modifications. The `.rel.text` and `.rel.data` sections are no longer required.

**Executable object file**

The format is similar to relocatable object file.  It includes the _entry point_ which is the first instruction to execute. There is also `.init` section which executes before the main program.

**Loading executable object file into memory**

The loader copies _(Map virtual memory pages)_ the code and data from the executable object file into memory and jumps to the _entry point_. The runtime _heap_ follows the `.data` section and grows upwards. The user stack starts from the largest legal user address (2<sup>48</sup> - 1) and grows down.

Heap, data and code segments actually have gaps between them due to alignment requirements and the address-space layout randomization.

![](images/Pasted%20image%2020211230215955.png)

**Shared libraries (Dynamic link libraries)**

Provide a mechanism where one executable copy can be shared between different programs. Unlike static libraries, the linking of references is deferred until load time or even runtime.

The linker does not resolve the references such as `printf()` during relocation. It only notes in the symbol table that these references will have to be resolved during load time. When executable file is created, linking is only <ins>partially complete</ins>.

During load time, the loader (execve) loads the executable and runs the dynamic linker. The dynamic linker allocates text and data of shared libraries into memory and relocate the references in the executable object file. Control is returned to the _entry point_ afterwards.

![](images/Pasted%20image%2020220429133046.png)

**Linking during runtime example**

```c
#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>

int x[2] = {1, 2};
int y[2] = {3, 4};
int z[2];

int main() {
	void *handle;
	void (*addvec)(int *, int *, int *, int);
	char *error;

	/* Dynamically load the shared library that contains addvec() */
	handle = dlopen("./libvector.so", RTLD_LAZY);
	if (!handle) {
		fprintf(stderr, "%s\n", dlerror());
		exit(1);
	}
	
	...
	
	
	/* Get a pointer to the addvec() function we just loaded */
	addvec = dlsym(handle, "addvec");
	if ((error = dlerror()) != NULL) {
		fprintf(stderr, "%s\n", error);
		exit(1);
	}
	
	/* Now we can call addvec() just like any other function */
	addvec(x, y, z, 2);
	printf("z = [%d %d]\n", z[0], z[1]);
	
	/* Unload the shared library */
	if (dlclose(handle) < 0) {
		fprintf(stderr, "%s\n", dlerror());
		exit(1);
	}
	return 0;
}
```

**Virtual Address Space of a Linux Process**

Kernel address space starts with 1 (top). User address space starts with 0 (bottom).

![](images/Pasted%20image%2020220115223403.png)